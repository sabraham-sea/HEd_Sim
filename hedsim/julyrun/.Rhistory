billable_leadrevenue<-readRDS('cpl_Junepred.RDS')
dat<-billable_leadrevenue%>%filter(cap_id==capid)
clusterno<-dat%>%select(clusno)
revdiff<-dat$forcast_billable-finalbillable
leaddiff=revdiff/dat$accepted_revenue
newlead<-dat$forcast -leaddiff%>%as.numeric()
newimp<-newlead/(dat$avg_ctr*dat$avg_cr)
allocatable_imp<-dat$pred_imp - newimp
newdat<-dat$pred_imp
billable_leadrevenue<-readRDS('cpl_Junepred.RDS')
dat<-billable_leadrevenue%>%filter(cap_id==capid)
clusterno<-dat%>%select(clusno)
revdiff<-dat$forcast_billable-finalbillable
leaddiff=revdiff/dat$accepted_revenue
View(dat)
newlead<-dat$forcast -leaddiff%>%as.numeric()
newimp<-newlead/(dat$avg_ctr*dat$avg_cr)
allocatable_imp<-dat$pred_imp - newimp
newdat<-dat$pred_imp
newdat$forcast<-newlead
View(newdat)
newlead
newdat
billable_leadrevenue<-readRDS('cpl_Junepred.RDS')
dat<-billable_leadrevenue%>%filter(cap_id==capid)
clusterno<-dat%>%select(clusno)
revdiff<-dat$forcast_billable-finalbillable
leaddiff=revdiff/dat$accepted_revenue
newlead<-dat$forcast -leaddiff%>%as.numeric()
newimp<-newlead/(dat$avg_ctr*dat$avg_cr)
allocatable_imp<-dat$pred_imp - newimp
newdat<-dat$pred_imp
newdat
newdat<-dat
newdat$forcast<-newlead
newdat$forcast_billable<-newdat$forcast*newdat$accepted_revenue
newdat$pred_imp<-newimp
View(newdat)
newbillable_leadrevenue<-billable_leadrevenue%>%filter(!cap_id==capid)
newbillable_leadrevenue<-rbind(newdat,newbillable_leadrevenue)
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
newbillable_leadrevenue<-billable_leadrevenue%>%filter(!cap_id==capid)
newbillable_leadrevenue<-rbind(newdat,newbillable_leadrevenue)
objdat<-newbillable_leadrevenue%>%filter(clusno==clusterno$clusno)
View(objdat)
f.obj <- objdat$avg_erpi
count<-nrow(objdat)
a<-matrix(1,1,count)
b<-diag(count)
f.con<-rbind(a,b)
conts1=sum(objdat$pred_imp,allocatable_imp)
f.dir <- c("<=","=",">=",">=")   # Budget constraint for 3rd
conts2<-objdat$pred_imp
# Set right hand side coefficients
f.rhs <- c(conts1,conts2)
lp("max", f.obj, f.con, f.dir, f.rhs)$solution
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
revcapfrom=  alloc_gp$newimp[1]*alloc_gp$erpi[1]
conts2<-objdat$pred_imp
# Set right hand side coefficients
f.rhs <- c(conts1,conts2)
lp("max", f.obj, f.con, f.dir, f.rhs)$solution
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
objdat
newrev
sum(1069484,3027380)
lp("max", f.obj, f.con, f.dir, f.rhs)$solution
lp("max", f.obj, f.con, f.dir, f.rhs)
1069484 *0.2240735
0.2937006*3027380
0.2790704*384650.0
> 0.2937006*488326.2
0.2937006*488326.2
143421.7+107344.4
250766.1+ 239643
1069484 *0.2240735
3027380  * 0.2937006
384650 *0.2790704
239643+889143.3+107344.4
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
newrev$solution
newrev$objval
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
get_return(1014,500000)
get_return<-function(capid,finalbillable) {
billable_leadrevenue<-readRDS('cpl_Junepred.RDS')
dat<-billable_leadrevenue%>%filter(cap_id==capid)
clusterno<-dat%>%select(clusno)
revdiff<-dat$forcast_billable-finalbillable
leaddiff=revdiff/dat$accepted_revenue
newlead<-dat$forcast -leaddiff%>%as.numeric()
newimp<-newlead/(dat$avg_ctr*dat$avg_cr)
allocatable_imp<-dat$pred_imp - newimp
newdat<-dat
newdat$forcast<-newlead
newdat$forcast_billable<-newdat$forcast*newdat$accepted_revenue
newdat$pred_imp<-newimp
newbillable_leadrevenue<-billable_leadrevenue%>%filter(!cap_id==capid)
newbillable_leadrevenue<-rbind(newdat,newbillable_leadrevenue)
objdat<-newbillable_leadrevenue%>%filter(clusno==clusterno$clusno)
f.obj <- objdat$avg_erpi
count<-nrow(objdat)
a<-matrix(1,1,count)
b<-diag(count)
f.con<-rbind(a,b)
# f.con <- matrix(c(1,1,1,
#                   1,0,0,
#                   0,1,0,
#                   0,0,1)
#
#                 , nrow = 4, byrow = TRUE)
conts1=sum(objdat$pred_imp,allocatable_imp)
# Set unequality signs
f.dir <- c("<=","=",">=",">=")   # Budget constraint for 3rd
conts2<-objdat$pred_imp
# Set right hand side coefficients
f.rhs <- c(conts1,conts2)
lp("max", f.obj, f.con, f.dir, f.rhs)$solution
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
#finalrev<-sum(newrev$objval,revcapfrom)
return(newrev$objval)
}
get_return(1014,500000)
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
f.rhs <- c(conts1,conts2)
get_return<-function(capid,finalbillable) {
billable_leadrevenue<-readRDS('cpl_Junepred.RDS')
dat<-billable_leadrevenue%>%filter(cap_id==capid)
clusterno<-dat%>%select(clusno)
revdiff<-dat$forcast_billable-finalbillable
leaddiff=revdiff/dat$accepted_revenue
newlead<-dat$forcast -leaddiff%>%as.numeric()
newimp<-newlead/(dat$avg_ctr*dat$avg_cr)
allocatable_imp<-dat$pred_imp - newimp
newdat<-dat
newdat$forcast<-newlead
newdat$forcast_billable<-newdat$forcast*newdat$accepted_revenue
newdat$pred_imp<-newimp
newbillable_leadrevenue<-billable_leadrevenue%>%filter(!cap_id==capid)
newbillable_leadrevenue<-rbind(newdat,newbillable_leadrevenue)
objdat<-newbillable_leadrevenue%>%filter(clusno==clusterno$clusno)
f.obj <- objdat$avg_erpi
count<-nrow(objdat)
a<-matrix(1,1,count)
b<-diag(count)
f.con<-rbind(a,b)
# f.con <- matrix(c(1,1,1,
#                   1,0,0,
#                   0,1,0,
#                   0,0,1)
#
#                 , nrow = 4, byrow = TRUE)
conts1=sum(objdat$pred_imp,allocatable_imp)
# Set unequality signs
f.dir <- c("<=","=",">=",">=")   # Budget constraint for 3rd
conts2<-objdat$pred_imp
# Set right hand side coefficients
f.rhs <- c(conts1,conts2)
# lp("max", f.obj, f.con, f.dir, f.rhs)$solution
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
#finalrev<-sum(newrev$objval,revcapfrom)
return(newrev$objval)
}
get_return(3143,500000)
get_return(3143,500000)
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp()
runApp()
runApp()
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp()
runApp()
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
get_return(3143,500000)
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
shinyUI(pageWithSidebar(
titlePanel(title = h2("Visualizing SNAP", align = "center")),
sidebarPanel(
helpText("The USDA and AHA recommend the following daily guidelines..."),
sliderInput("budget",
label = "What is your weekly grocery budget? (SNAP benefits are
designed to cover 1/3 of your total food expenditure):",
min = 0, max = 100, value = 50),
uiOutput("plot_ui")
),
mainPanel(
div(style = "width:800px; height:600px;",
ggvisOutput("myPlot")
)
)
))
shinyServer(
function(input, output) {
# user inputs max amt spent on food/wk
budget <- reactive({
as.numeric(input$budget)
})
output$myPlot <- renderPlot({
# set up optimization eq maximizing protein given constraints
maxProt <- lp("max",
SNAP2$protPerServ,
rbind(SNAP2$fatPerServ, SNAP2$fatPerServ, SNAP2$costPerServ, SNAP2$sodiumPerServ, SNAP2$fiberPerServ, SNAP2$sugarPerServ, SNAP2$calsPerServ, SNAP2$calsPerServ, SNAP2$fruit, SNAP2$vegs, SNAP2$grains, SNAP2$grains, SNAP2$meatProtein, SNAP2$dairy),
c("<=", ">=", "<=", "<=", ">=", "<=", ">=", "<=", ">=", ">=", ">=", "<=", ">=", ">="),
c(245, 140, budget(), 16100, 217, 262.5, 12600, 17850, 16, 28, 9, 25, 6.4, 24))
# drop any variables that have a 0 coefficient in the model
maxProtVec <- maxProt$solution
x <- data.frame(SNAP2$food, SNAP2$foodGroup, SNAP2$protPerServ, maxProtVec)
x <- x[!(x$maxProtVec == 0),]
x <- droplevels(x)
# plot the optimization equation, i.e. food on x-axis and no. servings
# of each food on y-axis
myPlot <- x %>%
ggvis(~SNAP2.food, ~maxProtVec, fill = ~SNAP2.foodGroup) %>%
layer_points(size := "400", opacity := "0.8") %>%
add_axis("x", title = "", ticks = 14) %>%
add_axis("y", title = "Servings Per Week") %>%
bind_shiny("myPlot", "plot_ui")
})
})
shinyUI(pageWithSidebar(
titlePanel(title = h2("Visualizing SNAP", align = "center")),
sidebarPanel(
helpText("The USDA and AHA recommend the following daily guidelines..."),
sliderInput("budget",
label = "What is your weekly grocery budget? (SNAP benefits are
designed to cover 1/3 of your total food expenditure):",
min = 0, max = 100, value = 50),
uiOutput("plot_ui")
),
mainPanel(
div(style = "width:800px; height:600px;",
ggvisOutput("myPlot")
)
)
))
shinyServer(
function(input, output) {
# user inputs max amt spent on food/wk
budget <- reactive({
as.numeric(input$budget)
})
output$myPlot <- renderPlot({
# set up optimization eq maximizing protein given constraints
maxProt <- lp("max",
SNAP2$protPerServ,
rbind(SNAP2$fatPerServ, SNAP2$fatPerServ, SNAP2$costPerServ, SNAP2$sodiumPerServ, SNAP2$fiberPerServ, SNAP2$sugarPerServ, SNAP2$calsPerServ, SNAP2$calsPerServ, SNAP2$fruit, SNAP2$vegs, SNAP2$grains, SNAP2$grains, SNAP2$meatProtein, SNAP2$dairy),
c("<=", ">=", "<=", "<=", ">=", "<=", ">=", "<=", ">=", ">=", ">=", "<=", ">=", ">="),
c(245, 140, budget(), 16100, 217, 262.5, 12600, 17850, 16, 28, 9, 25, 6.4, 24))
# drop any variables that have a 0 coefficient in the model
maxProtVec <- maxProt$solution
x <- data.frame(SNAP2$food, SNAP2$foodGroup, SNAP2$protPerServ, maxProtVec)
x <- x[!(x$maxProtVec == 0),]
x <- droplevels(x)
# plot the optimization equation, i.e. food on x-axis and no. servings
# of each food on y-axis
myPlot <- x %>%
ggvis(~SNAP2.food, ~maxProtVec, fill = ~SNAP2.foodGroup) %>%
layer_points(size := "400", opacity := "0.8") %>%
add_axis("x", title = "", ticks = 14) %>%
add_axis("y", title = "Servings Per Week") %>%
bind_shiny("myPlot", "plot_ui")
})
})
shinyUI(pageWithSidebar(
titlePanel(title = h2("Visualizing SNAP", align = "center")),
sidebarPanel(
helpText("The USDA and AHA recommend the following daily guidelines..."),
sliderInput("budget",
label = "What is your weekly grocery budget? (SNAP benefits are
designed to cover 1/3 of your total food expenditure):",
min = 0, max = 100, value = 50),
uiOutput("plot_ui")
),
mainPanel(
div(style = "width:800px; height:600px;",
ggvisOutput("myPlot")
)
)
))
runApp('~/Documents/Github/Rshiny/newtest/test')
get_return('3143',500000)
billable_leadrevenue<-readRDS('cpl_Junepred.RDS')
dat<-billable_leadrevenue%>%filter(cap_id==capid)
clusterno<-dat%>%select(clusno)
revdiff<-dat$forcast_billable-finalbillable
leaddiff=revdiff/dat$accepted_revenue
newlead<-dat$forcast -leaddiff%>%as.numeric()
newimp<-newlead/(dat$avg_ctr*dat$avg_cr)
allocatable_imp<-dat$pred_imp - newimp
newdat<-dat
newdat$forcast<-newlead
newdat$forcast_billable<-newdat$forcast*newdat$accepted_revenue
newdat$pred_imp<-newimp
newbillable_leadrevenue<-billable_leadrevenue%>%filter(!cap_id==capid)
newbillable_leadrevenue<-rbind(newdat,newbillable_leadrevenue)
objdat<-newbillable_leadrevenue%>%filter(clusno==clusterno$clusno)
f.obj <- objdat$avg_erpi
count<-nrow(objdat)
a<-matrix(1,1,count)
b<-diag(count)
f.con<-rbind(a,b)
# f.con <- matrix(c(1,1,1,
#                   1,0,0,
#                   0,1,0,
#                   0,0,1)
#
#                 , nrow = 4, byrow = TRUE)
conts1=sum(objdat$pred_imp,allocatable_imp)
# Set unequality signs
f.dir <- c("<=","=",">=",">=")   # Budget constraint for 3rd
conts2<-objdat$pred_imp
# Set right hand side coefficients
f.rhs <- c(conts1,conts2)
# lp("max", f.obj, f.con, f.dir, f.rhs)$solution
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
newrev$objval
finalrev<-newrev$objval%>%as.numeric()
runApp('~/Documents/Github/Rshiny/newtest/test')
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
newrev=lp("max", f.obj, f.con, f.dir, f.rhs)
?lp
f.con <- matrix (c(1, 2, 3, 3, 2, 2), nrow=2, byrow=TRUE)
f.con
f.obj <- objdat$avg_erpi
count<-nrow(objdat)
a<-matrix(1,1,count)
b<-diag(count)
f.con<-rbind(a,b)
f.con
runApp('~/Documents/Github/Rshiny/newtest/test')
get_return('3143',500000)
get_return('1156',50000)
f.obj
f.con
f.dir
f.rhs
f.dir <- c("<=","=",">",">")
get_return('1156',50000)
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
observeEvent(rv$run2, {
updateTextInput(session, "capfromnewcnt", value=paste(prettyNum(number3())))
})
library(shiny)
library(ggplot2)
library(dplyr)
source("helper.R", local = TRUE)
# Define UI for application that outputs ggplot
ui <- fluidPage(titlePanel("VALAT"),
tabsetPanel(
tabPanel(title = "FORECAST",
sidebarLayout(
sidebarPanel(
selectInput(
"Partner",
h3("Partner"),
choices = list(
"Murphy",
"Quinn",
"Streeter" ,
"Dent" ,
"Malisos" ,
"Lamach"  ,
"Saintval"
),
selected = "Saintval"
),
actionButton("Submit", "Submit"),
h3("")
),
mainPanel(plotOutput("plot"))
)),
tabPanel(
title = "REALLOCATION",
splitLayout( numericInput(
inputId = "capfrom",
label = "Input capid",
value=3143,
min = 1,
max = 10000),
numericInput(
inputId = "capfrombudget1",
label = "Current budget",
min = 0,
max = 1000000,
value = ''
),
numericInput(
inputId = "capfromcnt",
label = "Current count",
min = 0,
max = 1000000,
value = ''
),
numericInput(
inputId = "capfrombudget2",
label = "Final budget",
min = 0,
max = 1000000,
value = ''
),
numericInput(
inputId = "capfromnewcnt",
label = "Revised Count",
min = 0,
max = 1000000,
value = ''
)),
# actionButton(inputId = "submit2",
#              label = "Submit"),
tableOutput("out1"),
textOutput("out2"),
textOutput("out3"),
numericInput(
inputId = "currrev",
label = "Current Revenue",
min = 0,
max = 1000000,
value = ''
),
numericInput(
inputId = "revised_rev",
label = "Revised Revenue",
min = 0,
max = 1000000,
value = ''
)
)
))
rv <- reactiveValues()
rv$run2 <- 0
# Define server logic required to output ggplot from helper function
server <- function(input, output, session) {
plot_List <- eventReactive(input$Submit, {
print("ran")
Helper(input$Partner)
})
#Output the plot
output$plot <- renderPlot({
plot = plot_List()
plot[[1]]
})
number1<-eventReactive(input$capfrom, {
print("ran")
captolist(input$capfrom)  # value 2
})
# output$out1<- renderText({
#   nbr = number1()
#     nbr[[1]]})
#
output$out1<- renderTable({
nbr = number1()
nbr[,]})
number2<-eventReactive(input$capfrom, {
print("ran")
capcurrent(input$capfrom)  # value 2
})
# output$out2<- renderText({
#   nbr = number2()
#   nbr[,]}
#
#   )
observeEvent(input$capfrom, {
name<-capcurrent(input$capfrom)
updateTextInput(session, "capfrombudget1", value=paste(prettyNum(name)))
rv$run2 <- rv$run2 + 1
})
observeEvent(rv$run2, {
name<-capcurrentcnt(input$capfrom)
updateTextInput(session, "capfromcnt", value=paste(prettyNum(name)))
rv$run2 <- rv$run2 + 1
})
observeEvent(rv$run2, {
name<-sumcurrrev(input$capfrom)
updateTextInput(session, "currrev", value=paste(prettyNum(name)))
rv$run2 <- rv$run2 + 1
})
# updateTextInput(session, "capfrombudget1", value = paste(number2))
number3<- eventReactive(input$capfrombudget2, {
delta_lead(input$capfrom,input$capfrombudget2)  # value 2
})
observeEvent(rv$run2, {
updateTextInput(session, "capfromnewcnt", value=paste(prettyNum(number3())))
})
number4<- eventReactive(input$capfrombudget2, {
get_return(input$capfrom,input$capfrombudget2)  # value 2
})
# observeEvent(input$capfrombudget2, {
#     updateTextInput(session, "revised_rev", value=paste(prettyNum(number4())))
#  })
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp('~/Documents/Github/Rshiny/newtest/test')
runApp()
runApp('~/Documents/Github/Rshiny/newtest/test')
?renderUI
?renderPrint
runApp('~/Documents/Github/Rshiny/newtest/test')
